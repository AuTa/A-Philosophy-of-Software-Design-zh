import{_ as e,e as t}from"./app.cfef1a77.js";import{_ as a,a as o,b as s}from"./00024.02eae1fe.js";const i={},n=t('<h1 id="\u7B2C-20-\u7AE0-\u8BBE\u8BA1\u6027\u80FD" tabindex="-1"><a class="header-anchor" href="#\u7B2C-20-\u7AE0-\u8BBE\u8BA1\u6027\u80FD" aria-hidden="true">#</a> \u7B2C 20 \u7AE0 \u8BBE\u8BA1\u6027\u80FD</h1><blockquote><p>Chapter 20 Designing for Performance</p></blockquote><blockquote><p>Up until this point, the discussion of software design has focused on complexity; the goal has been to make software as simple and understandable as possible. But what if you are working on a system that needs to be fast? How should performance considerations affect the design process? This chapter discusses how to achieve high performance without sacrificing clean design. The most important idea is still simplicity: not only does simplicity improve a system\u2019s design, but it usually makes systems faster.</p></blockquote><p>\u5230\u76EE\u524D\u4E3A\u6B62\uFF0C\u5173\u4E8E\u8F6F\u4EF6\u8BBE\u8BA1\u7684\u8BA8\u8BBA\u90FD\u96C6\u4E2D\u5728\u590D\u6742\u6027\u4E0A\u3002\u76EE\u6807\u662F\u4F7F\u8F6F\u4EF6\u5C3D\u53EF\u80FD\u7B80\u5355\u6613\u61C2\u3002\u4F46\u662F\uFF0C\u5982\u679C\u60A8\u5728\u9700\u8981\u5FEB\u901F\u7684\u7CFB\u7EDF\u4E0A\u5DE5\u4F5C\uFF0C\u8BE5\u600E\u4E48\u529E\uFF1F\u6027\u80FD\u65B9\u9762\u7684\u8003\u8651\u5E94\u5982\u4F55\u5F71\u54CD\u8BBE\u8BA1\u8FC7\u7A0B\uFF1F\u672C\u7AE0\u8BA8\u8BBA\u5982\u4F55\u5728\u4E0D\u727A\u7272\u7B80\u6D01\u8BBE\u8BA1\u7684\u60C5\u51B5\u4E0B\u5B9E\u73B0\u9AD8\u6027\u80FD\u3002\u6700\u91CD\u8981\u7684\u60F3\u6CD5\u4ECD\u7136\u662F\u7B80\u5355\u6027\uFF1A\u7B80\u5355\u6027\u4E0D\u4EC5\u53EF\u4EE5\u6539\u5584\u7CFB\u7EDF\u7684\u8BBE\u8BA1\uFF0C\u800C\u4E14\u901A\u5E38\u53EF\u4EE5\u4F7F\u7CFB\u7EDF\u66F4\u5FEB\u3002</p><h2 id="_20-1-how-to-think-about-performance-\u5982\u4F55\u8003\u8651\u6027\u80FD" tabindex="-1"><a class="header-anchor" href="#_20-1-how-to-think-about-performance-\u5982\u4F55\u8003\u8651\u6027\u80FD" aria-hidden="true">#</a> 20.1 How to think about performance \u5982\u4F55\u8003\u8651\u6027\u80FD</h2><blockquote><p>The first question to address is \u201Chow much should you worry about performance during the normal development process?\u201D If you try to optimize every statement for maximum speed, it will slow down development and create a lot of unnecessary complexity. Furthermore, many of the \u201Coptimizations\u201D won\u2019t actually help performance. On the other hand, if you completely ignore performance issues, it\u2019s easy to end up with a large number of significant inefficiencies spread throughout the code; the resulting system can easily be 5\u201310x slower than it needs to be. In this \u201Cdeath by a thousand cuts\u201D scenario it\u2019s hard to come back later and improve the performance, because there is no single improvement that will have much impact.</p></blockquote><p>\u8981\u89E3\u51B3\u7684\u7B2C\u4E00\u4E2A\u95EE\u9898\u662F\u201C\u60A8\u5728\u6B63\u5E38\u7684\u5F00\u53D1\u8FC7\u7A0B\u4E2D\u5E94\u8BE5\u4E3A\u6027\u80FD\u591A\u5C11\u62C5\u5FC3\uFF1F\u201D \u5982\u679C\u60A8\u5C1D\u8BD5\u4F18\u5316\u6BCF\u6761\u8BED\u53E5\u4EE5\u83B7\u5F97\u6700\u5927\u901F\u5EA6\uFF0C\u5219\u5B83\u5C06\u51CF\u6162\u5F00\u53D1\u901F\u5EA6\u5E76\u4EA7\u751F\u8BB8\u591A\u4E0D\u5FC5\u8981\u7684\u590D\u6742\u6027\u3002\u6B64\u5916\uFF0C\u8BB8\u591A\u201C\u4F18\u5316\u201D\u5B9E\u9645\u4E0A\u5BF9\u6027\u80FD\u6CA1\u6709\u5E2E\u52A9\u3002\u53E6\u4E00\u65B9\u9762\uFF0C\u5982\u679C\u60A8\u5B8C\u5168\u5FFD\u7565\u4E86\u6027\u80FD\u95EE\u9898\uFF0C\u5219\u5F88\u5BB9\u6613\u5BFC\u81F4\u904D\u53CA\u6574\u4E2A\u4EE3\u7801\u7684\u5927\u91CF\u6548\u7387\u4F4E\u4E0B\u3002\u7ED3\u679C\u7CFB\u7EDF\u5F88\u5BB9\u6613\u6BD4\u6240\u9700\u7684\u901F\u5EA6\u6162 5\u201310 \u500D\u3002\u5728\u8FD9\u79CD\u201C\u5343\u5200\u780D\u6B7B\u201D\u7684\u60C5\u51B5\u4E0B\uFF0C\u4EE5\u540E\u5F88\u96BE\u518D\u56DE\u6765\u63D0\u9AD8\u6027\u80FD\u4E86\uFF0C\u56E0\u4E3A\u6CA1\u6709\u5355\u4E00\u7684\u6539\u8FDB\u4F1A\u4EA7\u751F\u5F88\u5927\u7684\u5F71\u54CD\u3002</p><blockquote><p>The best approach is something between these extremes, where you use basic knowledge of performance to choose design alternatives that are \u201Cnaturally efficient\u201D yet also clean and simple. The key is to develop an awareness of which operations are fundamentally expensive. Here are a few examples of operations that are relatively expensive today:</p></blockquote><p>\u6700\u597D\u7684\u65B9\u6CD5\u662F\u4ECB\u4E8E\u8FD9\u4E24\u79CD\u6781\u7AEF\u4E4B\u95F4\uFF0C\u5728\u8FD9\u79CD\u6781\u7AEF\u60C5\u51B5\u4E0B\uFF0C\u60A8\u53EF\u4EE5\u4F7F\u7528\u6027\u80FD\u7684\u57FA\u672C\u77E5\u8BC6\u6765\u9009\u62E9\u201C\u81EA\u7136\u9AD8\u6548\u201D\u4F46\u53C8\u5E72\u51C0\u53C8\u7B80\u5355\u7684\u8BBE\u8BA1\u66FF\u4EE3\u65B9\u6848\u3002\u5173\u952E\u662F\u8981\u4E86\u89E3\u54EA\u4E9B\u64CD\u4F5C\u6839\u672C\u662F\u6602\u8D35\u7684\u3002\u4EE5\u4E0B\u662F\u4E00\u4E9B\u4ECA\u5929\u76F8\u5BF9\u6602\u8D35\u7684\u64CD\u4F5C\u793A\u4F8B\uFF1A</p><blockquote><ul><li>Network communication: even within a datacenter, a round-trip message exchange can take 10\u201350 \xB5s, which is tens of thousands of instruction times. Wide-area round-trips can take 10\u2013100 ms.</li><li>I/O to secondary storage: disk I/O operations typically take 5\u201310 ms, which is millions of instruction times. Flash storage takes 10\u2013100 \xB5s. New emerging nonvolatile memories may be as fast as 1 \xB5s, but this is still around 2000 instruction times.</li><li>Dynamic memory allocation (malloc in C, new in C++ or Java) typically involves significant overhead for allocation, freeing, and garbage collection.</li><li>Cache misses: fetching data from DRAM into an on-chip processor cache takes a few hundred instruction times; in many programs, overall performance is determined as much by cache misses as by computational costs.</li></ul></blockquote><hr><ul><li>\u7F51\u7EDC\u901A\u4FE1\uFF1A\u5373\u4F7F\u5728\u6570\u636E\u4E2D\u5FC3\u5185\uFF0C\u5F80\u8FD4\u6D88\u606F\u4EA4\u6362\u4E5F\u53EF\u80FD\u82B1\u8D39 10\u201350 \xB5s\uFF0C\u8FD9\u662F\u6570\u4EE5\u4E07\u8BA1\u7684\u6307\u4EE4\u65F6\u95F4\u3002\u5E7F\u57DF\u5F80\u8FD4\u53EF\u80FD\u9700\u8981 10 \u5230 100 \u6BEB\u79D2\u3002</li><li>I/O \u5230\u8F85\u52A9\u5B58\u50A8\uFF1A\u78C1\u76D8 I/O \u64CD\u4F5C\u901A\u5E38\u9700\u8981 5 \u5230 10 \u6BEB\u79D2\uFF0C\u8FD9\u662F\u6570\u767E\u4E07\u6761\u6307\u4EE4\u65F6\u95F4\u3002\u95EA\u5B58\u5B58\u50A8\u9700\u8981 10\u2013100 \xB5s\u3002\u65B0\u51FA\u73B0\u7684\u975E\u6613\u5931\u6027\u5B58\u50A8\u5668\u7684\u901F\u5EA6\u53EF\u80FD\u9AD8\u8FBE 1 \xB5s\uFF0C\u4F46\u8FD9\u4ECD\u7EA6\u4E3A 2000 \u6761\u6307\u4EE4\u65F6\u95F4\u3002</li><li>\u52A8\u6001\u5185\u5B58\u5206\u914D\uFF08C \u8BED\u8A00\u4E2D\u7684 malloc\uFF0C C++ \u6216 Java \u4E2D\u7684\u65B0\u589E\u529F\u80FD\uFF09\u901A\u5E38\u6D89\u53CA\u5206\u914D\uFF0C\u91CA\u653E\u548C\u5783\u573E\u56DE\u6536\u7684\u5927\u91CF\u5F00\u9500\u3002</li><li>\u9AD8\u901F\u7F13\u5B58\u672A\u547D\u4E2D\uFF1A\u5C06\u6570\u636E\u4ECE DRAM \u63D0\u53D6\u5230\u7247\u4E0A\u5904\u7406\u5668\u9AD8\u901F\u7F13\u5B58\u4E2D\u9700\u8981\u6570\u767E\u6761\u6307\u4EE4\u65F6\u95F4\uFF1B\u5728\u8BB8\u591A\u7A0B\u5E8F\u4E2D\uFF0C\u6574\u4F53\u6027\u80FD\u53D6\u51B3\u4E8E\u7F13\u5B58\u672A\u547D\u4E2D\u548C\u8BA1\u7B97\u6210\u672C\u3002</li></ul><blockquote><p>The best way to learn which things are expensive is to run micro-benchmarks (small programs that measure the cost of a single operation in isolation). In the RAMCloud project, we created a simple program that provides a framework for microbenchmarks. It took a few days to create the framework, but the framework makes it possible to add new micro-benchmarks in five or ten minutes. This has allowed us to accumulate dozens of micro-benchmarks. We use these both to understand the performance of existing libraries used in RAMCloud, and also to measure the performance of new classes written for RAMCloud.</p></blockquote><p>\u4E86\u89E3\u54EA\u4E9B\u4E1C\u897F\u6700\u6602\u8D35\u7684\u6700\u597D\u65B9\u6CD5\u662F\u8FD0\u884C\u5FAE\u57FA\u51C6\u6D4B\u8BD5\uFF08\u5C0F\u578B\u7A0B\u5E8F\uFF0C\u8FD9\u4E9B\u7A0B\u5E8F\u5355\u72EC\u6D4B\u91CF\u5355\u4E2A\u64CD\u4F5C\u7684\u6210\u672C\uFF09\u3002\u5728 RAMCloud \u9879\u76EE\u4E2D\uFF0C\u6211\u4EEC\u521B\u5EFA\u4E86\u4E00\u4E2A\u7B80\u5355\u7684\u7A0B\u5E8F\uFF0C\u8BE5\u7A0B\u5E8F\u63D0\u4F9B\u4E86\u5FAE\u57FA\u51C6\u6D4B\u8BD5\u7684\u6846\u67B6\u3002\u521B\u5EFA\u8BE5\u6846\u67B6\u82B1\u4E86\u51E0\u5929\u65F6\u95F4\uFF0C\u4F46\u662F\u8BE5\u6846\u67B6\u4F7F\u5728\u4E94\u5230\u5341\u5206\u949F\u5185\u6DFB\u52A0\u65B0\u7684\u5FAE\u57FA\u51C6\u6210\u4E3A\u53EF\u80FD\u3002\u8FD9\u4F7F\u6211\u4EEC\u79EF\u7D2F\u4E86\u51E0\u5341\u4E2A\u5FAE\u57FA\u51C6\u3002\u6211\u4EEC\u65E2\u53EF\u4EE5\u4F7F\u7528\u5B83\u4EEC\u6765\u4E86\u89E3 RAMCloud \u4E2D\u4F7F\u7528\u7684\u73B0\u6709\u5E93\u7684\u6027\u80FD\uFF0C\u4E5F\u53EF\u4EE5\u8861\u91CF\u4E3A RAMCloud \u7F16\u5199\u7684\u65B0\u7C7B\u7684\u6027\u80FD\u3002</p><blockquote><p>Once you have a general sense for what is expensive and what is cheap, you can use that information to choose cheap operations whenever possible. In many cases, a more efficient approach will be just as simple as a slower approach. For example, when storing a large collection of objects that will be looked up using a key value, you could use either a hash table or an ordered map. Both are commonly available in library packages, and both are simple and clean to use. However, hash tables can easily be 5\u201310x faster. Thus, you should always use a hash table unless you need the ordering properties provided by the map.</p></blockquote><p>\u4E00\u65E6\u5BF9\u4EC0\u4E48\u662F\u6602\u8D35\u548C\u4EC0\u4E48\u4FBF\u5B9C\u6709\u4E86\u4E00\u822C\u7684\u8BA4\u8BC6\uFF0C\u5C31\u53EF\u4EE5\u4F7F\u7528\u8BE5\u4FE1\u606F\u5C3D\u53EF\u80FD\u5730\u9009\u62E9\u4FBF\u5B9C\u7684\u4E1A\u52A1\u3002\u5728\u8BB8\u591A\u60C5\u51B5\u4E0B\uFF0C\u66F4\u6709\u6548\u7684\u65B9\u6CD5\u5C06\u4E0E\u8F83\u6162\u7684\u65B9\u6CD5\u4E00\u6837\u7B80\u5355\u3002\u4F8B\u5982\uFF0C\u5F53\u5B58\u50A8\u5C06\u4F7F\u7528\u952E\u503C\u67E5\u627E\u7684\u5927\u91CF\u5BF9\u8C61\u65F6\uFF0C\u53EF\u4EE5\u4F7F\u7528\u54C8\u5E0C\u8868\u6216\u6709\u5E8F\u6620\u5C04\u3002\u4E24\u8005\u90FD\u901A\u5E38\u5728\u5E93\u5305\u4E2D\u63D0\u4F9B\uFF0C\u5E76\u4E14\u90FD\u7B80\u5355\u6613\u7528\u3002\u4F46\u662F\uFF0C\u54C8\u5E0C\u8868\u53EF\u4EE5\u8F7B\u677E\u5730\u5FEB 5-10 \u500D\u3002\u56E0\u6B64\uFF0C\u9664\u975E\u9700\u8981\u6620\u5C04\u63D0\u4F9B\u7684\u6392\u5E8F\u5C5E\u6027\uFF0C\u5426\u5219\u5E94\u59CB\u7EC8\u4F7F\u7528\u54C8\u5E0C\u8868\u3002</p><blockquote><p>As another example, consider allocating an array of structures in a language such as C or C++. There are two ways you can do this. One way is for the array to hold pointers to structures, in which case you must first allocate space for the array, then allocate space for each individual structure. It is much more efficient to store the structures in the array itself, so you only allocate one large block for everything.</p></blockquote><p>\u4F5C\u4E3A\u53E6\u4E00\u4E2A\u793A\u4F8B\uFF0C\u8BF7\u8003\u8651\u4F7F\u7528\u8BF8\u5982 C \u6216 C++ \u4E4B\u7C7B\u7684\u8BED\u8A00\u5206\u914D\u7ED3\u6784\u6570\u7EC4\u3002\u6709\u4E24\u79CD\u65B9\u6CD5\u53EF\u4EE5\u6267\u884C\u6B64\u64CD\u4F5C\u3002\u4E00\u79CD\u65B9\u6CD5\u662F\u8BA9\u6570\u7EC4\u4FDD\u7559\u6307\u5411\u7ED3\u6784\u7684\u6307\u9488\uFF0C\u5728\u8FD9\u79CD\u60C5\u51B5\u4E0B\uFF0C\u60A8\u5FC5\u987B\u9996\u5148\u4E3A\u6570\u7EC4\u5206\u914D\u7A7A\u95F4\uFF0C\u7136\u540E\u4E3A\u6BCF\u4E2A\u5355\u72EC\u7684\u7ED3\u6784\u5206\u914D\u7A7A\u95F4\u3002\u5C06\u7ED3\u6784\u5B58\u50A8\u5728\u6570\u7EC4\u672C\u8EAB\u4E2D\u6548\u7387\u8981\u9AD8\u5F97\u591A\uFF0C\u56E0\u6B64\u60A8\u53EA\u4E3A\u6240\u6709\u5185\u5BB9\u5206\u914D\u4E00\u4E2A\u5927\u5757\u3002</p><blockquote><p>If the only way to improve efficiency is by adding complexity, then the choice is more difficult. If the more efficient design adds only a small amount of complexity, and if the complexity is hidden, so it doesn\u2019t affect any interfaces, then it may be worthwhile (but beware: complexity is incremental). If the faster design adds a lot of implementation complexity, or if it results in more complicated interfaces, then it may be better to start off with the simpler approach and optimize later if performance turns out to be a problem. However, if you have clear evidence that performance will be important in a particular situation, then you might as well implement the faster approach immediately.</p></blockquote><p>\u5982\u679C\u63D0\u9AD8\u6548\u7387\u7684\u552F\u4E00\u65B9\u6CD5\u662F\u589E\u52A0\u590D\u6742\u6027\uFF0C\u90A3\u4E48\u9009\u62E9\u5C31\u66F4\u52A0\u56F0\u96BE\u3002\u5982\u679C\u66F4\u9AD8\u6548\u7684\u8BBE\u8BA1\u4EC5\u589E\u52A0\u4E86\u5C11\u91CF\u590D\u6742\u6027\uFF0C\u5E76\u4E14\u590D\u6742\u6027\u662F\u9690\u85CF\u7684\uFF0C\u56E0\u6B64\u5B83\u4E0D\u5F71\u54CD\u4EFB\u4F55\u63A5\u53E3\uFF0C\u90A3\u4E48\u5B83\u53EF\u80FD\u662F\u503C\u5F97\u7684\uFF08\u4F46\u8981\u6CE8\u610F\uFF1A\u590D\u6742\u6027\u662F\u9012\u589E\u7684\uFF09\u3002\u5982\u679C\u66F4\u5FEB\u7684\u8BBE\u8BA1\u589E\u52A0\u4E86\u5F88\u591A\u5B9E\u73B0\u590D\u6742\u6027\uFF0C\u6216\u8005\u5BFC\u81F4\u66F4\u590D\u6742\u7684\u63A5\u53E3\uFF0C\u90A3\u4E48\u6700\u597D\u662F\u4ECE\u66F4\u7B80\u5355\u7684\u65B9\u6CD5\u5F00\u59CB\uFF0C\u7136\u540E\u5728\u6027\u80FD\u51FA\u73B0\u95EE\u9898\u65F6\u8FDB\u884C\u4F18\u5316\u3002\u4F46\u662F\uFF0C\u5982\u679C\u60A8\u6709\u660E\u786E\u7684\u8BC1\u636E\u8868\u660E\u6027\u80FD\u5728\u7279\u5B9A\u60C5\u51B5\u4E0B\u5F88\u91CD\u8981\uFF0C\u90A3\u4E48\u60A8\u6700\u597D\u7ACB\u5373\u5B9E\u65BD\u66F4\u5FEB\u7684\u65B9\u6CD5\u3002</p><blockquote><p>In the RAMCloud project one of our overall goals was to provide the lowest possible latency for client machines accessing the storage system over a datacenter network. As a result, we decided to use special hardware for networking, which allowed RAMCloud to bypass the kernel and communicate directly with the network interface controller to send and receive packets. We made this decision even though it added complexity, because we knew from prior measurements that kernel-based networking would be too slow to meet our needs. In most of the rest of the RAMCloud system we were able to design for simplicity; getting this one big issue \u201Cright\u201D made many other things easier.</p></blockquote><p>\u5728 RAMCloud \u9879\u76EE\u4E2D\uFF0C\u6211\u4EEC\u7684\u603B\u4F53\u76EE\u6807\u4E4B\u4E00\u662F\u4E3A\u5BA2\u6237\u7AEF\u8BA1\u7B97\u673A\u901A\u8FC7\u6570\u636E\u4E2D\u5FC3\u7F51\u7EDC\u8BBF\u95EE\u5B58\u50A8\u7CFB\u7EDF\u63D0\u4F9B\u5C3D\u53EF\u80FD\u4F4E\u7684\u5EF6\u8FDF\u3002\u7ED3\u679C\uFF0C\u6211\u4EEC\u51B3\u5B9A\u4F7F\u7528\u7279\u6B8A\u7684\u786C\u4EF6\u8FDB\u884C\u8054\u7F51\uFF0C\u4ECE\u800C\u4F7F RAMCloud \u7ED5\u8FC7\u5185\u6838\u5E76\u76F4\u63A5\u4E0E\u7F51\u7EDC\u63A5\u53E3\u63A7\u5236\u5668\u8FDB\u884C\u901A\u4FE1\u4EE5\u53D1\u9001\u548C\u63A5\u6536\u6570\u636E\u5305\u3002\u5373\u4F7F\u589E\u52A0\u4E86\u590D\u6742\u6027\uFF0C\u6211\u4EEC\u8FD8\u662F\u505A\u51FA\u4E86\u8FD9\u4E2A\u51B3\u5B9A\uFF0C\u56E0\u4E3A\u6211\u4EEC\u4ECE\u5148\u524D\u7684\u6D4B\u91CF\u4E2D\u77E5\u9053\uFF0C\u57FA\u4E8E\u5185\u6838\u7684\u7F51\u7EDC\u592A\u6162\u4E86\uFF0C\u65E0\u6CD5\u6EE1\u8DB3\u6211\u4EEC\u7684\u9700\u6C42\u3002\u5728\u5176\u4F59\u7684 RAMCloud \u7CFB\u7EDF\u4E2D\uFF0C\u6211\u4EEC\u80FD\u591F\u8FDB\u884C\u7B80\u5355\u8BBE\u8BA1\u3002\u89E3\u51B3\u8FD9\u4E2A\u5927\u95EE\u9898\u201C\u5BF9\u201D\u4F7F\u5176\u4ED6\u4E8B\u60C5\u53D8\u5F97\u66F4\u52A0\u5BB9\u6613\u3002</p><blockquote><p>In general, simpler code tends to run faster than complex code. If you have defined away special cases and exceptions, then no code is needed to check for those cases and the system runs faster. Deep classes are more efficient than shallow ones, because they get more work done for each method call. Shallow classes result in more layer crossings, and each layer crossing adds overhead.</p></blockquote><p>\u901A\u5E38\uFF0C\u8F83\u7B80\u5355\u7684\u4EE3\u7801\u5F80\u5F80\u6BD4\u590D\u6742\u7684\u4EE3\u7801\u8FD0\u884C\u66F4\u5FEB\u3002\u5982\u679C\u60A8\u5B9A\u4E49\u4E86\u7279\u6B8A\u60C5\u51B5\u548C\u4F8B\u5916\uFF0C\u5219\u65E0\u9700\u4EE3\u7801\u5373\u53EF\u68C0\u67E5\u8FD9\u4E9B\u60C5\u51B5\uFF0C\u5E76\u4E14\u7CFB\u7EDF\u8FD0\u884C\u901F\u5EA6\u66F4\u5FEB\u3002\u6DF1\u5C42\u7C7B\u6BD4\u6D45\u5C42\u7C7B\u66F4\u6709\u6548\uFF0C\u56E0\u4E3A\u5B83\u4EEC\u4E3A\u6BCF\u4E2A\u65B9\u6CD5\u8C03\u7528\u5B8C\u6210\u4E86\u66F4\u591A\u5DE5\u4F5C\u3002\u6D45\u7C7B\u4F1A\u5BFC\u81F4\u66F4\u591A\u7684\u5C42\u4EA4\u53C9\uFF0C\u5E76\u4E14\u6BCF\u4E2A\u5C42\u4EA4\u53C9\u90FD\u4F1A\u589E\u52A0\u5F00\u9500\u3002</p><h2 id="_20-2-measure-before-modifying-\u4FEE\u6539\u524D\u7684\u5EA6\u91CF" tabindex="-1"><a class="header-anchor" href="#_20-2-measure-before-modifying-\u4FEE\u6539\u524D\u7684\u5EA6\u91CF" aria-hidden="true">#</a> 20.2 Measure before modifying \u4FEE\u6539\u524D\u7684\u5EA6\u91CF</h2><blockquote><p>But suppose that your system is still too slow, even though you have designed it as described above. It\u2019s tempting to rush off and start making performance tweaks, based on your intuitions about what is slow. Don\u2019t do this! Programmers\u2019 intuitions about performance are unreliable. This is true even for experienced developers. If you start making changes based on intuition, you\u2019ll waste time on things that don\u2019t actually improve performance, and you\u2019ll probably make the system more complicated in the process.</p></blockquote><p>\u4F46\u662F\uFF0C\u5373\u4F7F\u60A8\u5982\u4E0A\u6240\u8FF0\u8FDB\u884C\u8BBE\u8BA1\uFF0C\u4E5F\u8BF7\u5047\u8BBE\u60A8\u7684\u7CFB\u7EDF\u4ECD\u7136\u592A\u6162\u3002\u6839\u636E\u60A8\u5BF9\u6162\u901F\u8FD0\u52A8\u7684\u76F4\u89C9\uFF0C\u6025\u4E8E\u7740\u624B\u5F00\u59CB\u8FDB\u884C\u6027\u80FD\u8C03\u6574\u3002\u4E0D\u8981\u8FD9\u6837\uFF01\u7A0B\u5E8F\u5458\u5BF9\u6027\u80FD\u7684\u76F4\u89C9\u662F\u4E0D\u53EF\u9760\u7684\u3002\u5373\u4F7F\u5BF9\u4E8E\u6709\u7ECF\u9A8C\u7684\u5F00\u53D1\u4EBA\u5458\u4E5F\u662F\u5982\u6B64\u3002\u5982\u679C\u60A8\u5F00\u59CB\u6839\u636E\u76F4\u89C9\u8FDB\u884C\u66F4\u6539\uFF0C\u5219\u4F1A\u6D6A\u8D39\u65F6\u95F4\u5728\u5B9E\u9645\u4E0A\u65E0\u6CD5\u63D0\u9AD8\u6027\u80FD\u7684\u4E8B\u60C5\u4E0A\uFF0C\u5E76\u4E14\u53EF\u80FD\u4F1A\u4F7F\u7CFB\u7EDF\u53D8\u5F97\u66F4\u52A0\u590D\u6742\u3002</p><blockquote><p>Before making any changes, measure the system\u2019s existing behavior. This serves two purposes. First, the measurements will identify the places where performance tuning will have the biggest impact. It isn\u2019t sufficient just to measure the top-level system performance. This may tell you that the system is too slow, but it won\u2019t tell you why. You\u2019ll need to measure deeper to identify in detail the factors that contribute to overall performance; the goal is to identify a small number of very specific places where the system is currently spending a lot of time, and where you have ideas for improvement. The second purpose of the measurements is to provide a baseline, so that you can re-measure performance after making your changes to ensure that performance actually improved. If the changes didn\u2019t make a measurable difference in performance, then back them out (unless they made the system simpler). There\u2019s no point in retaining complexity unless it provides a significant speedup.</p></blockquote><p>\u8FDB\u884C\u4EFB\u4F55\u66F4\u6539\u4E4B\u524D\uFF0C\u8BF7\u6D4B\u91CF\u7CFB\u7EDF\u7684\u73B0\u6709\u884C\u4E3A\u3002\u8FD9\u6709\u4E24\u4E2A\u76EE\u7684\u3002\u9996\u5148\uFF0C\u8FD9\u4E9B\u6D4B\u91CF\u5C06\u786E\u5B9A\u6027\u80FD\u8C03\u6574\u5C06\u4EA7\u751F\u6700\u5927\u5F71\u54CD\u7684\u5730\u65B9\u3002\u4EC5\u4EC5\u6D4B\u91CF\u9876\u7EA7\u7CFB\u7EDF\u6027\u80FD\u662F\u4E0D\u591F\u7684\u3002\u8FD9\u53EF\u80FD\u4F1A\u544A\u8BC9\u60A8\u7CFB\u7EDF\u901F\u5EA6\u592A\u6162\uFF0C\u4F46\u4E0D\u4F1A\u544A\u8BC9\u60A8\u539F\u56E0\u3002\u60A8\u9700\u8981\u8FDB\u884C\u66F4\u6DF1\u5165\u7684\u8861\u91CF\uFF0C\u4EE5\u8BE6\u7EC6\u786E\u5B9A\u5F71\u54CD\u6574\u4F53\u7EE9\u6548\u7684\u56E0\u7D20\uFF1B\u76EE\u6807\u662F\u786E\u5B9A\u7CFB\u7EDF\u5F53\u524D\u82B1\u8D39\u5927\u91CF\u65F6\u95F4\u7684\u5C11\u91CF\u975E\u5E38\u5177\u4F53\u7684\u5730\u65B9\uFF0C\u4EE5\u53CA\u60A8\u6709\u6539\u8FDB\u60F3\u6CD5\u7684\u5730\u65B9\u3002\u6D4B\u91CF\u7684\u7B2C\u4E8C\u4E2A\u76EE\u7684\u662F\u63D0\u4F9B\u57FA\u7EBF\uFF0C\u4EE5\u4FBF\u60A8\u53EF\u4EE5\u5728\u8FDB\u884C\u66F4\u6539\u540E\u91CD\u65B0\u6D4B\u91CF\u6027\u80FD\uFF0C\u4EE5\u786E\u4FDD\u6027\u80FD\u5F97\u5230\u5B9E\u9645\u6539\u5584\u3002\u5982\u679C\u8FD9\u4E9B\u66F4\u6539\u5E76\u672A\u5728\u6548\u679C\u4E0A\u5E26\u6765\u53EF\u8861\u91CF\u7684\u53D8\u5316\uFF0C\u7136\u540E\u5C06\u5176\u9000\u51FA\uFF08\u9664\u975E\u5B83\u4EEC\u4F7F\u7CFB\u7EDF\u66F4\u7B80\u5355\uFF09\u3002\u9664\u975E\u80FD\u591F\u663E\u7740\u63D0\u9AD8\u901F\u5EA6\uFF0C\u5426\u5219\u4FDD\u6301\u590D\u6742\u6027\u6BEB\u65E0\u610F\u4E49\u3002</p><h2 id="_20-3-design-around-the-critical-path-\u56F4\u7ED5\u5173\u952E\u8DEF\u5F84\u8FDB\u884C\u8BBE\u8BA1" tabindex="-1"><a class="header-anchor" href="#_20-3-design-around-the-critical-path-\u56F4\u7ED5\u5173\u952E\u8DEF\u5F84\u8FDB\u884C\u8BBE\u8BA1" aria-hidden="true">#</a> 20.3 Design around the critical path \u56F4\u7ED5\u5173\u952E\u8DEF\u5F84\u8FDB\u884C\u8BBE\u8BA1</h2><blockquote><p>At this point, let\u2019s assume that you have carefully analyzed performance and have identified a piece of code that is slow enough to affect the overall system performance. The best way to improve its performance is with a \u201Cfundamental\u201D change, such as introducing a cache, or using a different algorithmic approach (balanced tree vs. list, for instance). Our decision to bypass the kernel for network communication in RAMCloud is an example of a fundamental fix. If you can identify a fundamental fix, then you can implement it using the design techniques discussed in previous chapters.</p></blockquote><p>\u5728\u8FD9\u4E00\u70B9\u4E0A\uFF0C\u6211\u4EEC\u5047\u8BBE\u60A8\u5DF2\u7ECF\u4ED4\u7EC6\u5206\u6790\u4E86\u6027\u80FD\uFF0C\u5E76\u786E\u5B9A\u4E86\u4E00\u6BB5\u7F13\u6162\u7684\u4EE3\u7801\u6765\u5F71\u54CD\u6574\u4E2A\u7CFB\u7EDF\u7684\u6027\u80FD\u3002\u6539\u5584\u5176\u6027\u80FD\u7684\u6700\u4F73\u65B9\u6CD5\u662F\u8FDB\u884C\u201C\u6839\u672C\u201D\u66F4\u6539\uFF0C\u4F8B\u5982\u5F15\u5165\u7F13\u5B58\uFF0C\u6216\u4F7F\u7528\u5176\u4ED6\u7B97\u6CD5\u65B9\u6CD5\uFF08\u4F8B\u5982\uFF0C\u5E73\u8861\u6811\u4E0E\u5217\u8868\uFF09\u3002\u6211\u4EEC\u51B3\u5B9A\u7ED5\u8FC7\u5185\u6838\u8FDB\u884C RAMCloud \u4E2D\u7684\u7F51\u7EDC\u901A\u4FE1\u7684\u51B3\u5B9A\u662F\u4E00\u4E2A\u57FA\u672C\u4FEE\u8865\u7A0B\u5E8F\u7684\u793A\u4F8B\u3002\u5982\u679C\u60A8\u53EF\u4EE5\u786E\u5B9A\u57FA\u672C\u4FEE\u590D\u7A0B\u5E8F\uFF0C\u5219\u53EF\u4EE5\u4F7F\u7528\u524D\u9762\u5404\u7AE0\u4E2D\u8BA8\u8BBA\u7684\u8BBE\u8BA1\u6280\u672F\u6765\u5B9E\u65BD\u5B83\u3002</p><blockquote><p>Unfortunately, situations will sometimes arise where there isn\u2019t a fundamental fix. This brings us to the core issue for this chapter, which is how to redesign an existing piece of code so that it runs faster. This should be your last resort, and it shouldn\u2019t happen often, but there are cases where it can make a big difference. The key idea is to design the code around the critical path.</p></blockquote><p>\u4E0D\u5E78\u7684\u662F\uFF0C\u6709\u65F6\u4F1A\u51FA\u73B0\u4E00\u4E9B\u6839\u672C\u65E0\u6CD5\u89E3\u51B3\u7684\u60C5\u51B5\u3002\u8FD9\u5C06\u6211\u4EEC\u5E26\u5230\u672C\u7AE0\u7684\u6838\u5FC3\u95EE\u9898\uFF0C\u5373\u5982\u4F55\u91CD\u65B0\u8BBE\u8BA1\u73B0\u6709\u4EE3\u7801\uFF0C\u4F7F\u5176\u8FD0\u884C\u66F4\u5FEB\u3002\u8FD9\u5E94\u8BE5\u662F\u60A8\u7684\u4E0D\u5F97\u5DF2\u7684\u65B9\u6CD5\uFF0C\u5E76\u4E14\u4E0D\u5E94\u8BE5\u7ECF\u5E38\u53D1\u751F\uFF0C\u4F46\u662F\u5728\u67D0\u4E9B\u60C5\u51B5\u4E0B\u5B83\u53EF\u80FD\u4F1A\u5E26\u6765\u5F88\u5927\u7684\u4E0D\u540C\u3002\u5173\u952E\u601D\u60F3\u662F\u56F4\u7ED5\u5173\u952E\u8DEF\u5F84\u8BBE\u8BA1\u4EE3\u7801\u3002</p><blockquote><p>Start off by asking yourself what is the smallest amount of code that must be executed to carry out the desired task in the common case. Disregard any existing code structure. Imagine instead that you are writing a new method that implements just the critical path, which is the minimum amount of code that must be executed in the the most common case. The current code is probably cluttered with special cases; ignore them in this exercise. The current code might pass through several method calls on the critical path; imagine instead that you could put all the relevant code in a single method. The current code may also use a variety of variables and data structures; consider only the data needed for the critical path, and assume whatever data structure is most convenient for the critical path. For example, it may make sense to combine multiple variables into a single value. Assume that you could completely redesign the system in order to minimize the code that must be executed for the critical path. Let\u2019s call this code \u201Cthe ideal.\u201D</p></blockquote><p>\u9996\u5148\uFF0C\u95EE\u81EA\u5DF1\u5728\u901A\u5E38\u60C5\u51B5\u4E0B\u6267\u884C\u6240\u9700\u4EFB\u52A1\u5FC5\u987B\u6267\u884C\u7684\u6700\u5C11\u4EE3\u7801\u91CF\u662F\u591A\u5C11\u3002\u5FFD\u7565\u4EFB\u4F55\u73B0\u6709\u7684\u4EE3\u7801\u7ED3\u6784\u3002\u76F8\u53CD\uFF0C\u60F3\u8C61\u4E00\u4E0B\u60A8\u6B63\u5728\u7F16\u5199\u4E00\u4E2A\u4EC5\u5B9E\u73B0\u5173\u952E\u8DEF\u5F84\u7684\u65B0\u65B9\u6CD5\uFF0C\u8FD9\u662F\u5728\u6700\u5E38\u89C1\u7684\u60C5\u51B5\u4E0B\u5FC5\u987B\u6267\u884C\u7684\u6700\u5C11\u4EE3\u7801\u91CF\u3002\u5F53\u524D\u7684\u4EE3\u7801\u53EF\u80FD\u5145\u6EE1\u7279\u6B8A\u60C5\u51B5\u3002\u5728\u6B64\u7EC3\u4E60\u4E2D\uFF0C\u8BF7\u5FFD\u7565\u5B83\u4EEC\u3002\u5F53\u524D\u7684\u4EE3\u7801\u53EF\u80FD\u4F1A\u5728\u5173\u952E\u8DEF\u5F84\u4E0A\u901A\u8FC7\u591A\u4E2A\u65B9\u6CD5\u8C03\u7528\u3002\u60F3\u8C61\u4E00\u4E0B\uFF0C\u60A8\u53EF\u4EE5\u5C06\u6240\u6709\u76F8\u5173\u4EE3\u7801\u653E\u5728\u4E00\u4E2A\u65B9\u6CD5\u4E2D\u3002\u5F53\u524D\u4EE3\u7801\u8FD8\u53EF\u4EE5\u4F7F\u7528\u5404\u79CD\u53D8\u91CF\u548C\u6570\u636E\u7ED3\u6784\u3002\u4EC5\u8003\u8651\u5173\u952E\u8DEF\u5F84\u6240\u9700\u7684\u6570\u636E\uFF0C\u5E76\u5047\u5B9A\u6700\u9002\u5408\u5173\u952E\u8DEF\u5F84\u7684\u4EFB\u4F55\u6570\u636E\u7ED3\u6784\u3002\u4F8B\u5982\uFF0C\u5C06\u591A\u4E2A\u53D8\u91CF\u5408\u5E76\u4E3A\u4E00\u4E2A\u503C\u53EF\u80FD\u5F88\u6709\u610F\u4E49\u3002\u5047\u8BBE\u60A8\u53EF\u4EE5\u5B8C\u5168\u91CD\u65B0\u8BBE\u8BA1\u7CFB\u7EDF\uFF0C\u4EE5\u6700\u5927\u7A0B\u5EA6\u5730\u51CF\u5C11\u5FC5\u987B\u4E3A\u5173\u952E\u8DEF\u5F84\u6267\u884C\u7684\u4EE3\u7801\u3002\u6211\u4EEC\u5C06\u6B64\u4EE3\u7801\u79F0\u4E3A\u201C\u7406\u60F3\u201D\u3002</p><blockquote><p>The ideal code probably clashes with your existing class structure, and it may not be practical, but it provides a good target: this represents the simplest and fastest that the code can ever be. The next step is to look for a new design that comes as close as possible to the ideal while still having a clean structure. You can apply all of the design ideas from previous chapters of this book, but with the additional constraint of keeping the ideal code (mostly) intact. You may have to add a bit of extra code to the ideal in order to allow clean abstractions; for example, if the code involves a hash table lookup, it\u2019s OK to introduce an extra method call to a general-purpose hash table class. In my experience it\u2019s almost always possible to find a design that is clean and simple, yet comes very close to the ideal.</p></blockquote><p>\u7406\u60F3\u7684\u4EE3\u7801\u53EF\u80FD\u4F1A\u4E0E\u60A8\u73B0\u6709\u7684\u7C7B\u7ED3\u6784\u51B2\u7A81\uFF0C\u5E76\u4E14\u53EF\u80FD\u4E0D\u5207\u5B9E\u9645\uFF0C\u4F46\u5B83\u63D0\u4F9B\u4E86\u4E00\u4E2A\u5F88\u597D\u7684\u76EE\u6807\uFF1A\u8FD9\u4EE3\u8868\u4E86\u4EE3\u7801\u53EF\u80FD\u662F\u6700\u7B80\u5355\uFF0C\u6700\u5FEB\u7684\u3002\u4E0B\u4E00\u6B65\u662F\u5BFB\u627E\u4E00\u79CD\u65B0\u8BBE\u8BA1\uFF0C\u4F7F\u5176\u5C3D\u53EF\u80FD\u63A5\u8FD1\u7406\u60F3\u72B6\u6001\uFF0C\u540C\u65F6\u53C8\u8981\u4FDD\u6301\u5E72\u51C0\u7684\u7ED3\u6784\u3002\u60A8\u53EF\u4EE5\u5E94\u7528\u672C\u4E66\u524D\u9762\u5404\u7AE0\u4E2D\u7684\u6240\u6709\u8BBE\u8BA1\u601D\u60F3\uFF0C\u4F46\u8981\u4FDD\u6301\uFF08\u6700\u597D\uFF09\u4FDD\u6301\u7406\u60F3\u4EE3\u7801\u7684\u9644\u52A0\u7EA6\u675F\u3002\u60A8\u53EF\u80FD\u9700\u8981\u5728\u7406\u60F3\u60C5\u51B5\u4E0B\u6DFB\u52A0\u4E00\u4E9B\u989D\u5916\u7684\u4EE3\u7801\uFF0C\u4EE5\u5141\u8BB8\u4F7F\u7528\u7B80\u6D01\u7684\u62BD\u8C61\u3002\u4F8B\u5982\uFF0C\u5982\u679C\u4EE3\u7801\u6D89\u53CA\u54C8\u5E0C\u8868\u67E5\u627E\uFF0C\u5219\u53EF\u4EE5\u5411\u901A\u7528\u54C8\u5E0C\u8868\u7C7B\u5F15\u5165\u989D\u5916\u7684\u65B9\u6CD5\u8C03\u7528\u3002\u4EE5\u6211\u7684\u7ECF\u9A8C\uFF0C\u51E0\u4E4E\u603B\u662F\u53EF\u4EE5\u627E\u5230\u5E72\u51C0\u7B80\u6D01\u7684\u8BBE\u8BA1\uFF0C\u4F46\u975E\u5E38\u63A5\u8FD1\u7406\u60F3\u3002</p><blockquote><p>One of the most important things that happens in this process is to remove special cases from the critical path. When code is slow, it\u2019s often because it must handle a variety of situations, and the code gets structured to simplify the handling of all the different cases. Each special case adds a little bit of code to the critical path, in the form of extra conditional statements and/or method calls. Each of these additions makes the code a bit slower. When redesigning for performance, try to minimize the number of special cases you must check. Ideally, there will be a single if statement at the beginning, which detects all special cases with one test. In the normal case, only this one test will need to be made, after which the the critical path can be executed with no additional tests for special cases. If the initial test fails (which means a special case has occurred) the code can branch to a separate place off the critical path to handle it. Performance isn\u2019t as important for special cases, so you can structure the special-case code for simplicity rather than performance.</p></blockquote><p>\u5728\u6B64\u8FC7\u7A0B\u4E2D\u53D1\u751F\u7684\u6700\u91CD\u8981\u7684\u4E8B\u60C5\u4E4B\u4E00\u662F\u4ECE\u5173\u952E\u8DEF\u5F84\u4E2D\u9664\u53BB\u7279\u6B8A\u60C5\u51B5\u3002\u5F53\u4EE3\u7801\u8FD0\u884C\u7F13\u6162\u65F6\uFF0C\u901A\u5E38\u662F\u56E0\u4E3A\u5B83\u5FC5\u987B\u5904\u7406\u5404\u79CD\u60C5\u51B5\uFF0C\u5E76\u4E14\u4EE3\u7801\u7ECF\u8FC7\u7ED3\u6784\u5316\u4EE5\u7B80\u5316\u6240\u6709\u4E0D\u540C\u60C5\u51B5\u7684\u5904\u7406\u3002\u6BCF\u4E2A\u7279\u6B8A\u60C5\u51B5\u90FD\u4EE5\u989D\u5916\u7684\u6761\u4EF6\u8BED\u53E5\u548C/\u6216\u65B9\u6CD5\u8C03\u7528\u7684\u5F62\u5F0F\u5411\u5173\u952E\u8DEF\u5F84\u6DFB\u52A0\u4E86\u4E00\u4E9B\u4EE3\u7801\u3002\u8FD9\u4E9B\u6DFB\u52A0\u4E2D\u7684\u6BCF\u4E00\u4E2A\u90FD\u4F1A\u4F7F\u4EE3\u7801\u53D8\u6162\u3002\u91CD\u65B0\u8BBE\u8BA1\u6027\u80FD\u65F6\uFF0C\u8BF7\u5C1D\u8BD5\u51CF\u5C11\u5FC5\u987B\u68C0\u67E5\u7684\u7279\u6B8A\u60C5\u51B5\u7684\u6570\u91CF\u3002\u7406\u60F3\u60C5\u51B5\u4E0B\uFF0C\u5F00\u5934\u5E94\u8BE5\u6709\u4E00\u4E2A if \u8BED\u53E5\uFF0C\u8BE5\u8BED\u53E5\u53EF\u4EE5\u901A\u8FC7\u4E00\u4E2A\u6D4B\u8BD5\u68C0\u6D4B\u6240\u6709\u7279\u6B8A\u60C5\u51B5\u3002\u5728\u6B63\u5E38\u60C5\u51B5\u4E0B\uFF0C\u53EA\u9700\u8981\u8FDB\u884C\u4E00\u9879\u6D4B\u8BD5\uFF0C\u4E4B\u540E\u5C31\u53EF\u4EE5\u6267\u884C\u5173\u952E\u8DEF\u5F84\uFF0C\u800C\u5BF9\u4E8E\u7279\u6B8A\u60C5\u51B5\u5219\u65E0\u9700\u8FDB\u884C\u5176\u4ED6\u6D4B\u8BD5\u3002\u5982\u679C\u521D\u59CB\u6D4B\u8BD5\u5931\u8D25\uFF08\u8FD9\u610F\u5473\u7740\u53D1\u751F\u4E86\u7279\u6B8A\u60C5\u51B5\uFF09\uFF0C\u5219\u4EE3\u7801\u53EF\u4EE5\u5206\u652F\u5230\u5173\u952E\u8DEF\u5F84\u4E4B\u5916\u7684\u5355\u72EC\u4F4D\u7F6E\u4EE5\u8FDB\u884C\u5904\u7406\u3002\u5BF9\u4E8E\u7279\u6B8A\u60C5\u51B5\uFF0C\u6027\u80FD\u5E76\u4E0D\u662F\u90A3\u4E48\u91CD\u8981\uFF0C\u56E0\u6B64\u60A8\u53EF\u4EE5\u4E3A\u7B80\u5316\u800C\u4E0D\u662F\u6027\u80FD\u6765\u6784\u9020\u7279\u6B8A\u60C5\u51B5\u7684\u4EE3\u7801\u3002</p><h2 id="_20-4-an-example-ramcloud-buffers-\u793A\u4F8B-ramcloud-\u7F13\u51B2\u533A" tabindex="-1"><a class="header-anchor" href="#_20-4-an-example-ramcloud-buffers-\u793A\u4F8B-ramcloud-\u7F13\u51B2\u533A" aria-hidden="true">#</a> 20.4 An example: RAMCloud Buffers \u793A\u4F8B\uFF1ARAMCloud \u7F13\u51B2\u533A</h2><blockquote><p>Let\u2019s consider an example, in which the Buffer class of the RAMCloud storage system was optimized to achieve a speedup of about 2x for the most common operations.</p></blockquote><p>\u8BA9\u6211\u4EEC\u8003\u8651\u4E00\u4E2A\u793A\u4F8B\uFF0C\u5176\u4E2D RAMCloud \u5B58\u50A8\u7CFB\u7EDF\u7684 Buffer \u7C7B\u7ECF\u8FC7\u4F18\u5316\uFF0C\u4EE5\u4F7F\u5927\u591A\u6570\u5E38\u89C1\u64CD\u4F5C\u7684\u901F\u5EA6\u63D0\u9AD8\u7EA6 2 \u500D\u3002</p><blockquote><p>RAMCloud uses Buffer objects to manage variable-length arrays of memory, such as request and response messages for remote procedure calls. Buffers are designed to reduce overheads from memory copying and dynamic storage allocation. A Buffer stores what appears to be a linear array of bytes, but for efficiency it allows the underlying storage to be divided into multiple discontiguous chunks of memory, as shown in Figure 20.1. A Buffer is created by appending chunks of data. Each chunk is either external or internal. If a chunk is external, its storage is owned by the caller; the Buffer keeps a reference to this storage. External chunks are typically used for large chunks in order to avoid memory copies. If a chunk is internal, the Buffer owns the storage for the chunk; data supplied by the caller is copied into the Buffer\u2019s internal storage. Each Buffer contains a small built-in allocation, which is a block of memory available for storing internal chunks. If this space is exhausted, then the Buffer creates additional allocations, which must be freed when the Buffer is destroyed. Internal chunks are convenient for small chunks where the memory copying costs are negligible. Figure 20.1 shows a Buffer with 5 chunks: the first chunk is internal, the next two are external, and the final two chunks are internal.</p></blockquote><p>RAMCloud \u4F7F\u7528 Buffer \u5BF9\u8C61\u7BA1\u7406\u53EF\u53D8\u957F\u5EA6\u7684\u5185\u5B58\u6570\u7EC4\uFF0C\u4F8B\u5982\u8FDC\u7A0B\u8FC7\u7A0B\u8C03\u7528\u7684\u8BF7\u6C42\u548C\u54CD\u5E94\u6D88\u606F\u3002\u7F13\u51B2\u533A\u65E8\u5728\u51CF\u5C11\u5185\u5B58\u590D\u5236\u548C\u52A8\u6001\u5B58\u50A8\u5206\u914D\u7684\u5F00\u9500\u3002\u7F13\u51B2\u533A\u5B58\u50A8\u770B\u4F3C\u7EBF\u6027\u7684\u5B57\u8282\u6570\u7EC4\uFF0C\u4F46\u662F\u4E3A\u4E86\u63D0\u9AD8\u6548\u7387\uFF0C\u5B83\u5141\u8BB8\u5C06\u5E95\u5C42\u5B58\u50A8\u5212\u5206\u4E3A\u591A\u4E2A\u4E0D\u8FDE\u7EED\u7684\u5185\u5B58\u5757\uFF0C\u5982\u56FE 20.1 \u6240\u793A\u3002\u901A\u8FC7\u9644\u52A0\u6570\u636E\u5757\u6765\u521B\u5EFA\u7F13\u51B2\u533A\u3002\u6BCF\u4E2A\u5757\u90FD\u662F\u5916\u90E8\u7684\u6216\u5185\u90E8\u7684\u3002\u5982\u679C\u5757\u5728\u5916\u90E8\uFF0C\u5219\u5176\u5B58\u50A8\u7531\u8C03\u7528\u65B9\u62E5\u6709\uFF1B\u7F13\u51B2\u533A\u4FDD\u7559\u5BF9\u6B64\u5B58\u50A8\u7684\u5F15\u7528\u3002\u5916\u90E8\u5757\u901A\u5E38\u7528\u4E8E\u5927\u578B\u5757\uFF0C\u4EE5\u907F\u514D\u5185\u5B58\u590D\u5236\u3002\u5982\u679C\u5185\u90E8\u6709\u5757\uFF0C\u5219 Buffer \u62E5\u6709\u8BE5\u5757\u7684\u5B58\u50A8\uFF1B\u8C03\u7528\u8005\u63D0\u4F9B\u7684\u6570\u636E\u5C06\u88AB\u590D\u5236\u5230\u7F13\u51B2\u533A\u7684\u5185\u90E8\u5B58\u50A8\u5668\u4E2D\u3002\u6BCF\u4E2A\u7F13\u51B2\u533A\u5305\u542B\u4E00\u4E2A\u5C0F\u7684\u5185\u7F6E\u5206\u914D\uFF0C\u8FD9\u662F\u4E00\u4E2A\u5185\u5B58\u5757\uFF0C\u53EF\u7528\u4E8E\u5B58\u50A8\u5185\u90E8\u5757\u3002\u5982\u679C\u6B64\u7A7A\u95F4\u5DF2\u7528\u5B8C\uFF0C\u5219\u7F13\u51B2\u533A\u5C06\u521B\u5EFA\u5176\u4ED6\u5206\u914D\uFF0C\u9500\u6BC1\u7F13\u51B2\u533A\u65F6\u5FC5\u987B\u91CA\u653E\u8FD9\u4E9B\u5206\u914D\u3002\u5185\u90E8\u5757\u5BF9\u4E8E\u5185\u5B58\u590D\u5236\u6210\u672C\u53EF\u5FFD\u7565\u4E0D\u8BA1\u7684\u5C0F\u5757\u5F88\u65B9\u4FBF\u3002\u56FE 20.1 \u663E\u793A\u4E86\u5177\u6709 5 \u4E2A\u5757\u7684 Buffer\uFF1A\u7B2C\u4E00\u4E2A\u5757\u662F\u5185\u90E8\u7684\uFF0C\u63A5\u4E0B\u6765\u7684\u4E24\u4E2A\u5757\u662F\u5916\u90E8\u7684\uFF0C\u6700\u540E\u4E24\u4E2A\u5757\u662F\u5185\u90E8\u7684\u3002</p><p><img src="'+a+'" alt=""></p><blockquote><p>Figure 20.1: A Buffer object uses a collection of memory chunks to store what appears to be a linear array of bytes. Internal chunks are owned by the Buffer and freed when the Buffer is destroyed; external chunks are not owned by the Buffer.</p></blockquote><p>\u56FE 20.1\uFF1ABuffer \u5BF9\u8C61\u4F7F\u7528\u5185\u5B58\u5757\u7684\u96C6\u5408\u6765\u5B58\u50A8\u770B\u4F3C\u7EBF\u6027\u5B57\u8282\u6570\u7EC4\u3002\u5185\u90E8\u5757\u7531 Buffer \u62E5\u6709\uFF0C\u5E76\u5728 Buffer \u9500\u6BC1\u65F6\u91CA\u653E\uFF1B\u5916\u90E8\u5757\u4E0D\u5C5E\u4E8E\u7F13\u51B2\u533A\u3002</p><blockquote><p>The Buffer class itself represents a \u201Cfundamental fix,\u201D in that it eliminates expensive memory copies that would have been required without it. For example, when assembling a response message containing a short header and the contents of a large object in the RAMCloud storage system, RAMCloud uses a Buffer with two chunks. The first chunk is an internal one that contains the header; the second chunk is an external one that refers to the object contents in the RAMCloud storage system. The response can be collected in the Buffer without copying the large object.</p></blockquote><p>Buffer \u7C7B\u672C\u8EAB\u4EE3\u8868\u201C\u6839\u672C\u6027\u7684\u4FEE\u8865\u7A0B\u5E8F\u201D\uFF0C\u56E0\u4E3A\u5B83\u6D88\u9664\u4E86\u6CA1\u6709\u5B83\u5C31\u9700\u8981\u7684\u6602\u8D35\u7684\u5185\u5B58\u526F\u672C\u3002\u4F8B\u5982\uFF0C\u5728 RAMCloud \u5B58\u50A8\u7CFB\u7EDF\u4E2D\u7EC4\u88C5\u5305\u542B\u77ED\u6807\u5934\u548C\u5927\u5BF9\u8C61\u5185\u5BB9\u7684\u54CD\u5E94\u6D88\u606F\u65F6\uFF0CRAMCloud \u4F7F\u7528\u5E26\u6709\u4E24\u4E2A\u5757\u7684 Buffer\u3002\u7B2C\u4E00\u4E2A\u5757\u662F\u5305\u542B\u5934\u7684\u5185\u90E8\u5757\uFF1B\u7B2C\u4E8C\u4E2A\u5757\u662F\u4E00\u4E2A\u5916\u90E8\u5757\uFF0C\u5B83\u5F15\u7528 RAMCloud \u5B58\u50A8\u7CFB\u7EDF\u4E2D\u7684\u5BF9\u8C61\u5185\u5BB9\u3002\u53EF\u4EE5\u5728\u4E0D\u590D\u5236\u5927\u5BF9\u8C61\u7684\u60C5\u51B5\u4E0B\u5C06\u54CD\u5E94\u6536\u96C6\u5230\u7F13\u51B2\u533A\u4E2D\u3002</p><blockquote><p>Aside from the fundamental approach of allowing discontiguous chunks, we did not attempt to optimize the code of the Buffer class in the original implementation. Over time, however, we noticed Buffers being used in more and more situations; for example, at least four Buffers are created during the execution of each remote procedure call. Eventually, it became clear that speeding up the implementation of Buffer could have a noticeable impact on overall system performance. We decided to see if we could improve the performance of the Buffer class.</p></blockquote><p>\u9664\u4E86\u5141\u8BB8\u4E0D\u8FDE\u7EED\u5757\u7684\u57FA\u672C\u65B9\u6CD5\u5916\uFF0C\u6211\u4EEC\u6CA1\u6709\u5C1D\u8BD5\u5728\u539F\u59CB\u5B9E\u73B0\u4E2D\u4F18\u5316 Buffer \u7C7B\u7684\u4EE3\u7801\u3002\u4F46\u662F\uFF0C\u968F\u7740\u65F6\u95F4\u7684\u6D41\u901D\uFF0C\u6211\u4EEC\u6CE8\u610F\u5230\u7F13\u51B2\u533A\u8D8A\u6765\u8D8A\u591A\u5730\u88AB\u4F7F\u7528\u3002\u4F8B\u5982\uFF0C\u5728\u6BCF\u4E2A\u8FDC\u7A0B\u8FC7\u7A0B\u8C03\u7528\u7684\u6267\u884C\u671F\u95F4\uFF0C\u81F3\u5C11\u521B\u5EFA\u56DB\u4E2A\u7F13\u51B2\u533A\u3002\u6700\u7EC8\uFF0C\u5F88\u660E\u663E\uFF0C\u52A0\u901F Buffer \u7684\u5B9E\u73B0\u53EF\u80FD\u4F1A\u5BF9\u6574\u4F53\u7CFB\u7EDF\u6027\u80FD\u4EA7\u751F\u663E\u7740\u5F71\u54CD\u3002\u6211\u4EEC\u51B3\u5B9A\u770B\u770B\u662F\u5426\u53EF\u4EE5\u63D0\u9AD8 Buffer \u7C7B\u7684\u6027\u80FD\u3002</p><blockquote><p>The most common operation for Buffer is to allocate space for a small amount of new data using an internal chunk. This happens, for example, when creating headers for request and response messages. We decided to use this operation as the critical path for optimization. In the simplest possible case, the space can be allocated by enlarging the last existing chunk in the Buffer. However, this is only possible if the last existing chunk is internal, and if there is enough space in its allocation to accommodate the new data. The ideal code would perform a single check to confirm that the simple approach is possible, then it would adjust the size of the existing chunk.</p></blockquote><p>Buffer \u6700\u5E38\u89C1\u7684\u64CD\u4F5C\u662F\u4F7F\u7528\u5185\u90E8\u5757\u4E3A\u5C11\u91CF\u65B0\u6570\u636E\u5206\u914D\u7A7A\u95F4\u3002\u4F8B\u5982\uFF0C\u5728\u4E3A\u8BF7\u6C42\u548C\u54CD\u5E94\u6D88\u606F\u521B\u5EFA\u6807\u9898\u65F6\uFF0C\u5C31\u4F1A\u53D1\u751F\u8FD9\u79CD\u60C5\u51B5\u3002\u6211\u4EEC\u51B3\u5B9A\u5C06\u6B64\u64CD\u4F5C\u7528\u4F5C\u4F18\u5316\u7684\u5173\u952E\u8DEF\u5F84\u3002\u5728\u6700\u7B80\u5355\u7684\u60C5\u51B5\u4E0B\uFF0C\u53EF\u4EE5\u901A\u8FC7\u6269\u5927 Buffer \u4E2D\u6700\u540E\u5B58\u5728\u7684\u5757\u6765\u5206\u914D\u7A7A\u95F4\u3002\u4F46\u662F\uFF0C\u53EA\u6709\u5728\u6700\u540E\u4E00\u4E2A\u73B0\u6709\u5757\u4F4D\u4E8E\u5185\u90E8\uFF0C\u5E76\u4E14\u5176\u5206\u914D\u4E2D\u6709\u8DB3\u591F\u7684\u7A7A\u95F4\u6765\u5BB9\u7EB3\u65B0\u6570\u636E\u65F6\uFF0C\u624D\u6709\u53EF\u80FD\u8FD9\u6837\u505A\u3002\u7406\u60F3\u7684\u4EE3\u7801\u5C06\u6267\u884C\u4E00\u6B21\u68C0\u67E5\u4EE5\u786E\u8BA4\u7B80\u5355\u65B9\u6CD5\u662F\u5426\u53EF\u884C\uFF0C\u7136\u540E\u5C06\u8C03\u6574\u73B0\u6709\u5757\u7684\u5927\u5C0F\u3002</p><blockquote><p>Figure 20.2 shows the original code for the critical path, which starts with the method Buffer::alloc. In the fastest possible case, Buffer::alloc calls Buffer:: allocateAppend, which calls Buffer::Allocation::allocateAppend. From a performance standpoint, this code has two problems. The first problem is that numerous special cases are checked individually:</p></blockquote><p>\u56FE 20.2 \u663E\u793A\u4E86\u5173\u952E\u8DEF\u5F84\u7684\u539F\u59CB\u4EE3\u7801\uFF0C\u8BE5\u4EE3\u7801\u4EE5 Buffer :: alloc \u65B9\u6CD5\u5F00\u5934\u3002\u5728\u6700\u5FEB\u7684\u60C5\u51B5\u4E0B\uFF0CBuffer :: alloc \u8C03\u7528 Buffer :: allocateAppend\uFF0C\u540E\u8005\u8C03\u7528 Buffer :: Allocation :: allocateAppend\u3002\u4ECE\u6027\u80FD\u7684\u89D2\u5EA6\u6765\u770B\uFF0C\u6B64\u4EE3\u7801\u6709\u4E24\u4E2A\u95EE\u9898\u3002\u7B2C\u4E00\u4E2A\u95EE\u9898\u662F\u8981\u5355\u72EC\u68C0\u67E5\u8BB8\u591A\u7279\u6B8A\u60C5\u51B5\uFF1A</p><blockquote><ul><li>Buffer::allocateAppend checks to see if the Buffer currently has any allocations.</li><li>The code checks twice to see if the current allocation has enough room for the new data: once in Buffer::Allocation::allocateAppend, and again when its return value is tested by Buffer::allocateAppend.</li><li>Buffer::alloc tests the return value from Buffer::allocAppend to confirm yet again that the allocation succeeded.</li></ul></blockquote><hr><ul><li>Buffer::allocateAppend \u68C0\u67E5\u7F13\u51B2\u533A\u5F53\u524D\u662F\u5426\u6709\u4EFB\u4F55\u5206\u914D\u3002</li><li>\u4EE3\u7801\u68C0\u67E5\u4E24\u6B21\u4EE5\u67E5\u770B\u5F53\u524D\u5206\u914D\u662F\u5426\u6709\u8DB3\u591F\u7684\u7A7A\u95F4\u5BB9\u7EB3\u65B0\u6570\u636E\uFF1A\u4E00\u6B21\u5728 Buffer::Allocation::allocateAppend \u4E2D\uFF0C\u4E00\u6B21\u5728\u5176\u8FD4\u56DE\u503C\u7531 Buffer::allocateAppend \u6D4B\u8BD5\u65F6\u3002</li><li>Buffer::alloc \u6D4B\u8BD5 Buffer::allocAppend \u7684\u8FD4\u56DE\u503C\uFF0C\u4EE5\u518D\u6B21\u786E\u8BA4\u5206\u914D\u6210\u529F\u3002</li></ul><blockquote><p>Furthermore, rather than trying to expand the last chunk directly, the code allocates new space without any consideration of the last chunk. Then Buffer::alloc checks to see if that space happens to be adjacent to the last chunk, in which case it merges the new space with the existing chunk. This results in additional checks. Overall, this code tests 6 distinct conditions in the critical path.</p></blockquote><p>\u6B64\u5916\uFF0C\u8BE5\u4EE3\u7801\u6CA1\u6709\u5C1D\u8BD5\u76F4\u63A5\u6269\u5C55\u6700\u540E\u4E00\u4E2A\u5757\uFF0C\u800C\u662F\u5728\u4E0D\u8003\u8651\u6700\u540E\u4E00\u4E2A\u5757\u7684\u60C5\u51B5\u4E0B\u5206\u914D\u4E86\u65B0\u7A7A\u95F4\u3002\u7136\u540E\uFF0CBuffer::alloc \u68C0\u67E5\u8BE5\u7A7A\u95F4\u662F\u5426\u6070\u597D\u4E0E\u6700\u540E\u4E00\u5757\u76F8\u90BB\uFF0C\u5728\u8FD9\u79CD\u60C5\u51B5\u4E0B\uFF0C\u5B83\u5C06\u65B0\u7A7A\u95F4\u4E0E\u73B0\u6709\u5757\u5408\u5E76\u3002\u8FD9\u5BFC\u81F4\u5176\u4ED6\u68C0\u67E5\u3002\u603B\u4F53\u800C\u8A00\uFF0C\u6B64\u4EE3\u7801\u6D4B\u8BD5\u5173\u952E\u8DEF\u5F84\u4E2D\u7684 6 \u79CD\u4E0D\u540C\u6761\u4EF6\u3002</p><blockquote><p>The second problem with the original code is that it has too many layers, all of which are shallow. This is both a performance problem and a design problem. The critical path makes two additional method calls in addition to the original invocation of Buffer::alloc. Each method call takes additional time, and the result of each call must be checked by its caller, which results in more special cases to consider. Chapter 7 discussed how abstractions should normally change as you pass from one layer to another, but all three of the methods in Figure 20.2 have identical signatures and they provide essentially the same abstraction; this is a red flag. Buffer::allocateAppend is nearly a pass-though method; its only contribution is to create a new allocation if needed. The extra layers make the code both slower and more complicated.</p></blockquote><p>\u539F\u59CB\u4EE3\u7801\u7684\u7B2C\u4E8C\u4E2A\u95EE\u9898\u662F\u5B83\u5177\u6709\u592A\u591A\u7684\u5C42\uFF0C\u6240\u6709\u5C42\u90FD\u5F88\u6D45\u3002\u8FD9\u65E2\u662F\u6027\u80FD\u95EE\u9898\uFF0C\u4E5F\u662F\u8BBE\u8BA1\u95EE\u9898\u3002\u5173\u952E\u8DEF\u5F84\u9664\u4E86\u5BF9 Buffer::alloc \u7684\u539F\u59CB\u8C03\u7528\u4E4B\u5916\uFF0C\u8FD8\u8FDB\u884C\u4E86\u53E6\u5916\u4E24\u4E2A\u65B9\u6CD5\u8C03\u7528\u3002\u6BCF\u4E2A\u65B9\u6CD5\u8C03\u7528\u82B1\u8D39\u989D\u5916\u7684\u65F6\u95F4\uFF0C\u5E76\u4E14\u6BCF\u4E2A\u8C03\u7528\u7684\u7ED3\u679C\u5FC5\u987B\u7531\u5176\u8C03\u7528\u8005\u68C0\u67E5\uFF0C\u8FD9\u5BFC\u81F4\u9700\u8981\u8003\u8651\u66F4\u591A\u7279\u6B8A\u60C5\u51B5\u3002\u7B2C 7 \u7AE0\u8BA8\u8BBA\u4E86\u5F53\u60A8\u4ECE\u4E00\u5C42\u4F20\u9012\u5230\u53E6\u4E00\u5C42\u65F6\uFF0C\u62BD\u8C61\u901A\u5E38\u5E94\u8BE5\u5982\u4F55\u53D8\u5316\uFF0C\u4F46\u662F\u56FE 20.2 \u4E2D\u7684\u6240\u6709\u4E09\u79CD\u65B9\u6CD5\u90FD\u5177\u6709\u76F8\u540C\u7684\u7B7E\u540D\uFF0C\u5E76\u4E14\u5B83\u4EEC\u63D0\u4F9B\u4E86\u57FA\u672C\u76F8\u540C\u7684\u62BD\u8C61\u3002\u8FD9\u662F\u4E00\u4E2A\u5371\u9669\u4FE1\u53F7\u3002Buffer::allocateAppend \u51E0\u4E4E\u662F\u4E00\u4E2A\u4F20\u9012\u65B9\u6CD5\uFF1B\u5B83\u7684\u552F\u4E00\u4F5C\u7528\u662F\u5728\u9700\u8981\u65F6\u521B\u5EFA\u65B0\u7684\u5206\u914D\u3002\u989D\u5916\u7684\u5C42\u4F7F\u4EE3\u7801\u65E2\u6162\u53C8\u590D\u6742\u3002</p><blockquote><p>To fix these problems, we refactored the Buffer class so that its design is centered around the most performance-critical paths. We considered not just the allocation code above but several other commonly executed paths, such as retrieving the total number of bytes of data currently stored in a Buffer. For each of these critical paths, we tried to identify the smallest amount of code that must be executed in the common case. Then we designed the rest of the class around these critical paths. We also applied the design principles from this book to simplify the class in general. For example, we eliminated shallow layers and created deeper internal abstractions. The refactored class is 20% smaller than the original version (1476 lines of code, versus 1886 lines in the original).</p></blockquote><p>\u4E3A\u4E86\u89E3\u51B3\u8FD9\u4E9B\u95EE\u9898\uFF0C\u6211\u4EEC\u91CD\u6784\u4E86 Buffer \u7C7B\uFF0C\u4F7F\u5176\u8BBE\u8BA1\u56F4\u7ED5\u6700\u5173\u952E\u6027\u80FD\u7684\u8DEF\u5F84\u8FDB\u884C\u3002\u6211\u4EEC\u4E0D\u4EC5\u8003\u8651\u4E86\u4E0A\u9762\u7684\u5206\u914D\u4EE3\u7801\uFF0C\u8FD8\u8003\u8651\u4E86\u5176 \u200B\u200B \u4ED6\u51E0\u79CD\u5E38\u7528\u7684\u6267\u884C\u8DEF\u5F84\uFF0C\u4F8B\u5982\u68C0\u7D22\u5F53\u524D\u5B58\u50A8\u5728 Buffer \u4E2D\u7684\u6570\u636E\u7684\u5B57\u8282\u603B\u6570\u3002\u5BF9\u4E8E\u8FD9\u4E9B\u5173\u952E\u8DEF\u5F84\u4E2D\u7684\u6BCF\u4E00\u4E2A\uFF0C\u6211\u4EEC\u8BD5\u56FE\u786E\u5B9A\u5728\u901A\u5E38\u60C5\u51B5\u4E0B\u5FC5\u987B\u6267\u884C\u7684\u6700\u5C11\u4EE3\u7801\u91CF\u3002\u7136\u540E\uFF0C\u6211\u4EEC\u56F4\u7ED5\u8FD9\u4E9B\u5173\u952E\u8DEF\u5F84\u8BBE\u8BA1\u4E86\u8BFE\u7A0B\u7684\u5176\u4F59\u90E8\u5206\u3002\u6211\u4EEC\u8FD8\u5E94\u7528\u4E86\u672C\u4E66\u4E2D\u7684\u8BBE\u8BA1\u539F\u5219\u6765\u7B80\u5316\u6574\u4E2A\u7C7B\u3002\u4F8B\u5982\uFF0C\u6211\u4EEC\u6D88\u9664\u4E86\u6D45\u5C42\u5E76\u521B\u5EFA\u4E86\u66F4\u6DF1\u7684\u5185\u90E8\u62BD\u8C61\u3002\u91CD\u6784\u7684\u7C7B\u6BD4\u539F\u59CB\u7248\u672C\u5C0F 20\uFF05\uFF081476 \u884C\u4EE3\u7801\uFF0C\u800C\u539F\u59CB\u7248\u672C\u4E3A 1886 \u884C\uFF09\u3002</p><p><img src="'+o+'" alt=""></p><blockquote><p>Figure 20.2: The original code for allocating new space at the end of a Buffer, using an internal chunk.</p></blockquote><p>\u56FE 20.2\uFF1A\u4F7F\u7528\u5185\u90E8\u5757\u5728 Buffer \u7684\u672B\u5C3E\u5206\u914D\u65B0\u7A7A\u95F4\u7684\u539F\u59CB\u4EE3\u7801\u3002</p><p><img src="'+s+'" alt=""></p><blockquote><p>Figure 20.3: The new code for allocating new space in an internal chunk of a Buffer.</p></blockquote><p>\u56FE 20.3\uFF1A\u7528\u4E8E\u5728 Buffer \u7684\u5185\u90E8\u5757\u4E2D\u5206\u914D\u65B0\u7A7A\u95F4\u7684\u65B0\u4EE3\u7801\u3002</p><blockquote><p>Figure 20.3 shows the new critical path for allocating internal space in a Buffer. The new code is not only faster, but it is also easier to read, since it avoids shallow abstractions. The entire path is handled in a single method, and it uses a single test to rule out all of the special cases. The new code introduces a new instance variable, extraAppendBytes, in order to simplify the critical path. This variable keeps track of how much unused space is available immediately after the last chunk in the Buffer. If there is no space available, or if the last chunk in the Buffer isn\u2019t an internal chunk, or if the Buffer contains no chunks at all, then extraAppendBytes is zero. The code in Figure 20.3 represents the least possible amount of code to handle this common case.</p></blockquote><p>\u56FE 20.3 \u663E\u793A\u4E86\u7528\u4E8E\u5728 Buffer \u4E2D\u5206\u914D\u5185\u90E8\u7A7A\u95F4\u7684\u65B0\u5173\u952E\u8DEF\u5F84\u3002\u65B0\u4EE3\u7801\u4E0D\u4EC5\u901F\u5EA6\u66F4\u5FEB\uFF0C\u800C\u4E14\u66F4\u5BB9\u6613\u9605\u8BFB\uFF0C\u56E0\u4E3A\u5B83\u907F\u514D\u4E86\u6D45\u5C42\u62BD\u8C61\u3002\u6574\u4E2A\u8DEF\u5F84\u4F7F\u7528\u5355\u4E00\u65B9\u6CD5\u5904\u7406\uFF0C\u5E76\u4E14\u4F7F\u7528\u5355\u4E00\u6D4B\u8BD5\u6392\u9664\u6240\u6709\u7279\u6B8A\u60C5\u51B5\u3002\u65B0\u4EE3\u7801\u5F15\u5165\u4E86\u65B0\u7684\u5B9E\u4F8B\u53D8\u91CF extraAppendBytes\uFF0C\u4EE5\u7B80\u5316\u5173\u952E\u8DEF\u5F84\u3002\u6B64\u53D8\u91CF\u8DDF\u8E2A\u7F13\u51B2\u533A\u4E2D\u6700\u540E\u4E00\u4E2A\u5757\u4E4B\u540E\u7ACB\u5373\u6709\u591A\u5C11\u672A\u4F7F\u7528\u7A7A\u95F4\u53EF\u7528\u3002\u5982\u679C\u6CA1\u6709\u53EF\u7528\u7A7A\u95F4\uFF0C\u6216\u8005 Buffer \u4E2D\u7684\u6700\u540E\u4E00\u4E2A\u5757\u4E0D\u662F\u5185\u90E8\u5757\uFF0C\u6216\u8005 Buffer \u6839\u672C\u4E0D\u5305\u542B\u4EFB\u4F55\u5757\uFF0C\u5219 extraAppendBytes \u4E3A\u96F6\u3002\u56FE 20.3 \u4E2D\u7684\u4EE3\u7801\u8868\u793A\u5904\u7406\u8FD9\u79CD\u5E38\u89C1\u60C5\u51B5\u7684\u6700\u5C11\u4EE3\u7801\u91CF\u3002</p><blockquote><p>Note: the update to totalLength could have been eliminated by recomputing the total Buffer length from the individual chunks whenever it is needed. However, this approach would be expensive for a large Buffer with many chunks, and fetching the total Buffer length is another common operation. Thus, we chose to add a small amount of extra overhead to alloc in order to ensure that the Buffer length is always immediately available.</p></blockquote><p>\u6CE8\u610F\uFF1A\u53EA\u8981\u9700\u8981\uFF0C\u5C31\u53EF\u4EE5\u901A\u8FC7\u91CD\u65B0\u8BA1\u7B97\u5404\u4E2A\u5757\u7684\u603B\u7F13\u51B2\u533A\u957F\u5EA6\u6765\u6D88\u9664\u5BF9 totalLength \u7684\u66F4\u65B0\u3002\u4F46\u662F\uFF0C\u8FD9\u79CD\u65B9\u6CD5\u5BF9\u4E8E\u5177\u6709\u8BB8\u591A\u5757\u7684\u5927\u578B Buffer \u800C\u8A00\u5C06\u662F\u6602\u8D35\u7684\uFF0C\u5E76\u4E14\u83B7\u53D6 Buffer \u7684\u603B\u957F\u5EA6\u662F\u53E6\u4E00\u79CD\u5E38\u89C1\u7684\u64CD\u4F5C\u3002\u56E0\u6B64\uFF0C\u6211\u4EEC\u9009\u62E9\u6DFB\u52A0\u5C11\u91CF\u989D\u5916\u7684\u5F00\u9500\u6765\u5206\u914D\uFF0C\u4EE5\u786E\u4FDD Buffer \u957F\u5EA6\u59CB\u7EC8\u7ACB\u5373\u53EF\u7528\u3002</p><blockquote><p>The new code is about twice as fast as the old code: the total time to append a 1-byte string to a Buffer using internal storage dropped from 8.8 ns to 4.75 ns. Many other Buffer operations also speeded up because of the revisions. For example, the time to construct a new Buffer, append a small chunk in internal storage, and destroy the Buffer dropped from 24 ns to 12 ns.</p></blockquote><p>\u65B0\u4EE3\u7801\u7684\u901F\u5EA6\u7EA6\u4E3A\u65E7\u4EE3\u7801\u7684\u4E24\u500D\uFF1A\u4F7F\u7528\u5185\u90E8\u5B58\u50A8\u5C06 1 \u5B57\u8282\u5B57\u7B26\u4E32\u9644\u52A0\u5230\u7F13\u51B2\u533A\u7684\u603B\u65F6\u95F4\u4ECE 8.8 ns \u964D\u4F4E\u5230 4.75 ns\u3002\u7531\u4E8E\u4FEE\u8BA2\uFF0C\u8BB8\u591A\u5176\u4ED6\u7F13\u51B2\u533A\u64CD\u4F5C\u4E5F\u52A0\u5FEB\u4E86\u901F\u5EA6\u3002\u4F8B\u5982\uFF0C\u6784\u5EFA\u65B0\u7F13\u51B2\u533A\uFF0C\u5728\u5185\u90E8\u5B58\u50A8\u4E2D\u9644\u52A0\u4E00\u5C0F\u5757\u5E76\u9500\u6BC1\u7F13\u51B2\u533A\u6240\u9700\u7684\u65F6\u95F4\u4ECE 24 ns \u964D\u81F3 12 ns\u3002</p><h2 id="_20-5-conclusion-\u7ED3\u8BBA" tabindex="-1"><a class="header-anchor" href="#_20-5-conclusion-\u7ED3\u8BBA" aria-hidden="true">#</a> 20.5 Conclusion \u7ED3\u8BBA</h2><blockquote><p>The most important overall lesson from this chapter is that clean design and high performance are compatible. The Buffer class rewrite improved its performance by a factor of 2 while simplifying its design and reducing code size by 20%. Complicated code tends to be slow because it does extraneous or redundant work. On the other hand, if you write clean, simple code, your system will probably be fast enough that you don\u2019t have to worry much about performance in the first place. In the few cases where you do need to optimize performance, the key is simplicity again: find the critical paths that are most important for performance and make them as simple as possible.</p></blockquote><p>\u672C\u7AE0\u6700\u91CD\u8981\u7684\u603B\u4F53\u6559\u8BAD\u662F\uFF0C\u5E72\u51C0\u7684\u8BBE\u8BA1\u548C\u9AD8\u6027\u80FD\u662F\u517C\u5BB9\u7684\u3002\u91CD\u5199 Buffer \u7C7B\u53EF\u5C06\u5176\u6027\u80FD\u63D0\u9AD8 2 \u500D\uFF0C\u540C\u65F6\u7B80\u5316\u5176\u8BBE\u8BA1\u5E76\u5C06\u4EE3\u7801\u5927\u5C0F\u51CF\u5C11 20\uFF05\u3002\u590D\u6742\u7684\u4EE3\u7801\u901A\u5E38\u4F1A\u5F88\u6162\uFF0C\u56E0\u4E3A\u5B83\u4F1A\u6267\u884C\u591A\u4F59\u6216\u591A\u4F59\u7684\u5DE5\u4F5C\u3002\u53E6\u4E00\u65B9\u9762\uFF0C\u5982\u679C\u60A8\u7F16\u5199\u5E72\u51C0\uFF0C\u7B80\u5355\u7684\u4EE3\u7801\uFF0C\u5219\u7CFB\u7EDF\u53EF\u80FD\u4F1A\u8DB3\u591F\u5FEB\uFF0C\u56E0\u6B64\u60A8\u4E00\u5F00\u59CB\u5C31\u4E0D\u5FC5\u62C5\u5FC3\u6027\u80FD\u3002\u5728\u5C11\u6570\u9700\u8981\u4F18\u5316\u6027\u80FD\u7684\u60C5\u51B5\u4E0B\uFF0C\u5173\u952E\u518D\u6B21\u662F\u7B80\u5355\u6027\uFF1A\u627E\u5230\u5BF9\u6027\u80FD\u6700\u91CD\u8981\u7684\u5173\u952E\u8DEF\u5F84\u5E76\u4F7F\u5B83\u4EEC\u5C3D\u53EF\u80FD\u7B80\u5355\u3002</p>',80);function r(l,c){return n}var d=e(i,[["render",r],["__file","ch20.html.vue"]]);export{d as default};
